---
layout:          post
title:           Linux共享库的组织
subtitle:        《程序员的自我修养》第八章学习笔记
date:            2018-12-18
author:          rookflying
header-img:      img/cxyzwxy_chapter_8/background.png
catalog:         true
tags:
    - Linux
    - C
    - C++
---

# 1. 共享库版本

## 1.1 共享库兼容性

共享库的更新主要分两种：

- 兼容更新：只是在原有基础上添加一些内容，没有改变接口。
- 不兼容更新：改变了原有的接口，使用该共享库原有接口的程序可能不能运行或运行不正常。

这里说的接口主要是指二进制接口，即`ABI(Application Binary Interface)`，主要包括函数调用的堆栈结构，符号命名，参数规则，数据结构的内存分布等方面的规则。
例如导致C语言共享库ABI改变主要有以下4个：

- 导出函数的行为发生改变。
- 导出函数被删除。
- 导出数据的结构发生变化。
- 导处函数的接口发生变化，如函数返回值，参数被更改。

## 1.2 共享库版本命名

解决共享库兼容性的有效方法之一就是使用共享库版本的方法，Linux有一套规则来命名系统中的每一个共享库，如下：

```
libname.so.x.y.z
```

先是前缀`lib`，接着是库的名字，接着是后缀`.so`，最后是三个用`.`隔开的数字。`x`表示主版本号，`y`表示次版本号，`z`表示发布版本号。

主版本号表示库的重大升级，不同主版本号的库之间是不兼容的。

次版本号表示库的增量升级。在主版本号相同情况下，高的此版本号向后兼容低的次版本号。

发布版本号表示库的一些错误的修正，性能的改进等，不增加任何新的接口，也不对接口进行更改。因此相同主版本号，相同次版本号，不同的发布版本号之间完全兼容。

实际上，`Glibc`里的如C语言库和动态链接器没有遵守上面的命令规定，它们命名分别是如`libc_2.23.so`和`ld-2.23.so`。64位的系统可以在`lib/x86_64-linux-gnu`下看到。

## 1.3 SO-NAME

一个程序对于它自身所依赖的所有共享库，必须知道这些共享库的名字和主版本号，因为不同主板本号是不兼容的。

现在一般采用`SO-NAME`的命名机制来记录共享库的依赖关系。每个共享库都有一个对应的`SO-NAME`，`SO-NAME`其实就是去掉共享库文件名的次版本号和发布版本号。如一个共享库`libfoo.so.2.6.1`，则它的`SO-NAME`是`libfoo.so.2`。因此实际上`SO-NAME`规定了共享库的接口。在Linux下，系统会为每个共享库在它所在的目录创建一个名字为`SO-NAME`的并且指向它的软链接。如系统中存在一个共享库为`/lib/x86_64-linux-gnu/libacl.so.1.1.0`，则共享库管理程序会为它产生一个软链接`/lib/x86_64-linux-gnu/libacl.so.1`。

实际上这个软链会指向同目录中主版本号相同，次版本号和发布版本号最新的共享库。比如有两个共享库`/lib/libfoo.so.2.6.1`和`/lib/libfoo.2.5.3`，那么软链接`/lib/libfoo.so.2`指向的是`/lib/libfoo.so.2.6.1`。这样保证了所有以`SO-NAME`为名的软链接都指向系统中最新版本的共享库（相同主版本号下）。

因此当可执行文件依赖于某个共享库时，在`.dynamic`段里的保存的内容实际上是该共享库SO-NAME软链接，而不是具体的某个共享库文件。这样当共享库更新时，可执行文件不会受到影响，通过`SO-NAME`软链依然能够找到最新的共享库文件。反之如果`.dynamic`中保存的是具体的共享库文件，例如`/lib/libc-2.6.1.so`，那么当该共享库升级到`/lib/libc-2.7.1.so`时，系统必须要保留原来的`2.6.1`，否则该可执行文件将不能运行。利用`SO-NAME`机制，动态链接器会自动定位到`2.7.1`，`2.7.1`又是兼容`2.6.1`的，因此程序不会受影响。

当共享库有多个主版本号时，就会有多个对应的SO-NAME。

Linux下有一个工具叫做`ldconfig`，当系统中安装或更新一个共享库时，就需要运行这个工具，它会遍历所有的默认共享库目录，更新所有的软链接，保证它们指向最新的版本库，如果安装了新的共享库，则会创建相应的软链接。

可以在编译器命令行指定需要链接的共享库，比如需要链接一个`libXXX.so.2.6.1`共享库，只需要在编译器命令行里面指定`-lXXX`参数即可，编译器会根据当前环境，在系统中的相关路径查找最新版本的`XXX`库。

这个`XXX`就是共享库的链接名。但不同的类型库可能有同样的链接名，如C语言运行库有静态版本`libc.a`和动态版本`libc.so.x.y.z`。如果使用`-lc`参数，链接器会根据输出文件是静态还是动态来选择合适版本的库。如使用`-static`参数时，`-lc`会查找`libc.a`，使用`-Bdynamic`时（默认情况），会查找最新版本的`libc.so.x.y.z`。

# 2. 符号版本

动态链接器进行动态链接时，只进行主版本号的判断。这会存在一种叫做**次版本号交会问题**，次版本号更新有可能会添加接口。当某个程序在拥有较高的次版本号的共享库的系统中编译时，系统会记录该程序依赖于当前次版本号的共享库，而当运行在较低版本号的共享库系统时，可能会产生缺少某些符号的错误，这种情况下强制运行程序会遇到未知的错误，因此会提示不能运行该程序。但有些情况下可以运行，因为就算系统记录该程序依赖的是较高次版本号的共享库（仅仅是因为这个程序当时是在那个环境下编译的），但实际上如果该程序并没有用到新增的接口，那么在低此版本号共享库系统中也是可以运行的。因此存在一个问题，依赖于高次版本号共享库的程序在只有低次版本号共享库系统中到底应不应该运行。因此需要一种更精巧的方式，就是**符号版本**机制。

## 2.1 基于符号的版本机制

Linux下的`Glibc`从版本2.1之后开始支持一种叫做**基于符号的版本机制**。简单来说就是假设`libfoo.so.1.2`升级到`1.3`，此时依旧保留`libfoo.so.1`这个`SO-NAME`，但给`1.3`新增的全局符号加上一些标记，如`VERS_1.3`。那么每次当次版本号升级时，每个符号都有相应的标签，比如`VERS_1.1`，`VERS_1.2`，`VERS_1.3`等。

## 2.2 Solaris中的符号版本机制

`Solaris`的`ld`链接器为共享库新增了**版本机制**和**范围机制**。版本机制即使定义了一些符号的集合，如`VERS_1.1`，`VERS_1.2`。其中`VER_1.2`继承了`VERS_1.1`所有的符号。可以在链接共享库时编写**符号版本脚本**文件，这个文件指定符号和集合的关系，练级器根据这些关系做不同的操作。

一个符号版本脚本文件示例如下：

```
SUNW_1.1 { 	//定义了两个集合SUNW_1.1和SUNWprivate。
global: 	//SUNW_1.1包含两个全局符号pop，push
	pop;
	push;
}

SUNWprivate { 	//SUNWprivate包含__pop，__push。
global:
	__pop;
	__push;
local: 	//表示除了pop，push，__pop，__push，其他全局符号都成为局部符号，就是所谓的范围机制，不希望共享库使用者访问这些符号
	*;
}
```

当共享库升级，添加了`swap`，那么符号版本脚本文件添加如下内容：

```
SUM_1.2 {   //表示SUNW_1.2继承了SUNW_1.1的符号，且新增了swap
global:
	swap;
}SUNW_1.1;
```

多次更新后，就会相应有`SUM_1.3`，`SUM_1.4`等等。1表示主版本号，与`SO-NAME`对应，后面的表示次版本号。有了这种机制之后，假设`libfoo.so.1`中有6个符号，从`SUNW_1.1`到`SUNW_1.6`。当应用程序`app_foo`编译时，系统中的`libfoo.so.1`符号版本为`SUNW_1.6`，但实际上`app_foo`只用到了最高到`SUNW_1.3`的符号，则链接器会将`SUNW_1.3`记录到`app_foo`可执行文件中，而不是`SUNW_1.6`。因此只要保证当前系统共享库中次版本号大于等于3,程序就可以运行，而不一定要求次版本号为6。即可以判定在高次版本号编译的程序能否在低此版本号中运行。

## 2.3 Linux中的符号版本

GCC对`Solaris`符号版本机制进行了扩展：

- 提供`.symver`汇编宏指令来指定符号版本。

```C++
asm(".symver add, add@VERS_1.1"); 	//add指定为VERS_1.1

int add(int a,int b) {
	return a+b;
}
```

- 允许多个版本的同一个符号存在于一个共享库。

```C++
asm(".symver old_printf, printf@VERS_1.1");
asm(".symver new_printf, printf@VERS_1.2");

int old_printf() {}
int new_printf() {}
```

使用指定符号版本脚本文件编译一个共享库命令如下（`lib.ver`为符号版本脚本）：

```
gcc -shared -fPIC lib.c -Xlinker --version-script lib.ver -o lib.so
```

# 3. 共享库系统路径

- `/lib`存放系统最关键和基础的共享库。
- `/usr/lib`存放非系统运行时所需要的关键性的共享库，如开发时用到的共享库。
- `/usr/local/lib`存放一些第三方应用程序的库。

# 4. 共享库查找过程

一个程序依赖的共享库一般在`.dynamic`段中以相对路径来表示，动态链接器会在`/lib`，`/usr/lib`和由`/etc/ld.so.conf`配置文件指定的目录中查找共享库。为了提高效率，Linux系统下有一个`idconfig`的程序，作用是在共享库目录下创建，删除或更新相应的`SO-NAME`，并将这些`SO-NAME`收集存放到`/etc/ld.so.cache`文件里，即建立一个`SO-NAME`缓存。动态链接器先从该缓存里查找，查找失败再遍历`/lib`和`/usr/lib`这两个目录。

# 5. 环境变量

## 5.1 LD_LIBRARY_PATH

这个环境变量可以临时改变某个应用程序的共享库查找路径，而不会影响系统中的其他程序。如下：

```
LD_LIBRARY_PATH=home/user ./main
```

那么系统会先查找`LD_LIBRARY_PATH`指定的路径，再查找`SO-NAME`缓存，最后查找`/usr/lib`和`/lib`。最好不要将`LD_LIBRARY_PATH`导出至全局范围从而影响其他程序。

## 5.2 LD_PREOLOAD

通过`LD_PRELOAD`可以指定预先装载的共享库或者目标文件，比`LD_LIBRARY_PATH`还优先。因为有全局符号介入这个机制，`LD_PRELOAD`指定的共享库的全局符号会覆盖后面加载的同名符号。利用这个可以做到该县C库中某几个函数而不影响其他函数，有利于测试。配置文件`/etc/ld.so.preload`作用与`LD_PRELOAD`一样。最好仅用于测试，一个程序的发布版本不应该依赖于`LD_PRELOAD`。

## 5.3 LD_DEBUG

`LD_DEBUG`可以打开动态链接器的调试功能，不同的值有不同的功能：

- files:打印装载过程。
- bindings：显示动态链接的符号绑定过程。
- libs：显示共享库查找过程。
- versions：显示符号的版本依赖关系。
- reloc：显示重定位过程。
- symbols：显示符号查找过程。
- statistics：显示各种统计信息。
- all：显示以上所有信息。
- help：显示上面的各种可选值的帮助信息。

# 6. 共享库的创建和安装

## 6.1 共享库的创建

使用`GCC`的参数：

- -shared：表示输出结果是共享库类型的。
- -fPIC：表示使用地址无关代码技术生成输出文件。
- -Wl：表示将指定的参数传递给链接器。如`-Wl,-soname,my_soname`用来指定输出共享库的SO-NAME。

如有`libfoo1.c`和`libfoo2.c`，要生成`libfoo.so.1.0.0`共享库，该共享库依赖于`libbar1.so`和`libbar2.so`，则命令可以如下：

```
gcc -shared -fPIC -Wl,-soname,libfoo.so.1 -o libfoo.so.1.0.0 libfoo1.c libfoo2.c -lbar1 -lbar2
```

> 如果没有指定SO-NAME，共享库默认就没有`SO-NAME`，使用ldconfig对该共享库也没效果。

默认情况下，链接器在产生可执行文件时，只会将那些链接时被其他共享模块引用到的符号放到动态符号表中。即在共享模块反向引用主模块中的符号时，只有那些在链接时被共享模块引用到的符号才会被导出。这种情况下，当使用`dlopen()`动态加载某个共享库时，该共享库反向引用主模块的符号时，可能主模块的某些符号因为在链接时没有被其他共享模块引用而没有被放到动态符号表中，导致了反向引用失败。因此ld链接器提供`-export-dynamic`参数，表示链接时将所有全局符号导出到动态符号表。`GCC`中可以使用`-Wl,-export-dynamic`。

## 6.2 清除符号信息

使用`strip`清除共享库的符号信息，如`strip libfoo.so`。也可以使用ld的`-s`和`-S`参数，`-S`消除调试符号信息，`-s`消除所有符号信息。对应的GCC可以使用`-Wl,-s`和`-Wl,-S`。

## 6.3 共享库的安装

最简单的方法是将共享库复制到某个标准的共享库目录如`/lib`，`/usr/lib`等，然后运行`ldconfig`，这需要root权限。如果没有root权限，可以建立相应的`SO-NAME`，并告诉编译器和程序如何查找该共享库。建立`SO-NAME`也是使用`ldconfig`，需要指定共享库所在的目录：

```
ldconfig -n shared_library_directory
```

## 6.4 共享库构造和析构函数

在函数声明时加上`__attribute__((constructor))`的属性，即指定该函数为共享库构造函数。这种函数会共享库加载时被执行，即在`main`之前执行。如果是由`dlopen()`打开的共享库，会在该函数返回前执行。`__attribute__((destructor))`同理。

> 这种`__attribute__`语法是GCC对C和C++的扩展，其他编译器并不通用。

当有多个构造或析构函数时，可以指定优先级。对于构造，数字越小优先级越高，析构相反。优先级越高的函数越先执行，这种安排有利于构造函数和析构函数能够匹配。

```C++
void __attribute__((constructor(5))) init_function1(void);
```

## 6.5 共享库脚本

共享库除了是`.so`文件之外，还可以是符合一定格式的链接脚本文件。链接脚本文件是将几个现有的共享库通过一定方式组合起来，从用户的角度看就是一个新的共享库。如把C运行库和数学库组合成一个新的库`libfoo.so`。则`libfoo.so`的内容如下：

```
GROUP(/lib/libc.so.6 /lib/libm.so,2)
```



